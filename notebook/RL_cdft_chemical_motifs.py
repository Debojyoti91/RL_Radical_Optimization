# -*- coding: utf-8 -*-
"""RL_CDFT_Chemical_motifs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IUUTkdF68m4yRBqGZRqevmtJJrmskCOu
"""

from google.colab import drive
drive.mount('/content/drive')

# Import necessary libraries
import warnings
import numpy as np
import pandas as pd
import os, random, collections, re, pickle
from sklearn.model_selection import train_test_split
import torch
import torch.nn as nn, torch.optim as optim, torch.nn.functional as F
import matplotlib.pyplot as plt

# suppress warnings
warnings.filterwarnings("ignore")

import os
import pandas as pd

BASE = "/content/drive/MyDrive/RL_radical_dft/RL_radical_new_dataset"
RESULT_DIR = os.path.join(BASE, "Results")

TOP20_FILE = os.path.join(RESULT_DIR, "top20_radicals_val_unique.csv")
MOTIF_FILE = os.path.join(BASE, "dataset/Radical_Name_List-2.xlsx")

# Load files
top20_df = pd.read_csv(TOP20_FILE)
motif_df = pd.read_excel(MOTIF_FILE)

# Clean radical names
top20_df["Radical name"] = top20_df["Radical name"].astype(str).str.strip()
motif_df["Radical name"] = motif_df["Radical name"].astype(str).str.strip()

# Keep only needed columns from motif file
motif_sub = motif_df[["Radical name", "Classification"]].drop_duplicates()

# Merge Top20 descriptors with classifications
final_df = top20_df.merge(
    motif_sub,
    on="Radical name",
    how="left"
)

# Select columns to display
cols_to_show = ["Radical name", "Classification", "ω", "f⁻", "f⁺", "f⁰", "fukui_score", "total_score"]
final_out = final_df[cols_to_show]

print(final_out)

import pandas as pd
import os


# PATHS


BASE = "/content/drive/MyDrive/RL_radical_dft/RL_radical_new_dataset"
RESULT_DIR = os.path.join(BASE, "Results")

TOP20_FILE = os.path.join(RESULT_DIR, "top20_radicals_merged_unique.csv")
MOTIF_FILE = os.path.join(BASE, "dataset/Radical_Name_List-2.xlsx")

OUTCSV = os.path.join(RESULT_DIR, "motif_enrichment_full_vs_top20.csv")


# LOAD INPUT FILES


motif_df = pd.read_excel(MOTIF_FILE)
motif_df["Radical name"] = motif_df["Radical name"].astype(str).str.strip()

top_df = pd.read_csv(TOP20_FILE)
top_df["Radical name"] = top_df["Radical name"].astype(str).str.strip()


# FLAG TOP-20 RADICALS


motif_df["is_top20"] = motif_df["Radical name"].isin(top_df["Radical name"])


# MOTIF STATS


# full dataset distribution
full_counts = motif_df["Classification"].value_counts().sort_index()
full_pct    = full_counts / full_counts.sum()

# top-20 distribution
top_counts = (
    motif_df[motif_df["is_top20"]]["Classification"]
    .value_counts()
    .reindex(full_counts.index, fill_value=0)
)
top_pct = top_counts / top_counts.sum()

# enrichment
enrichment = (top_pct / full_pct).replace([pd.NA, float("inf")], 0)


# OUTPUT TABLE


out = pd.DataFrame({
    "motif_class": full_counts.index,
    "count_full": full_counts.values,
    "pct_full": full_pct.values,
    "count_top20": top_counts.values,
    "pct_top20": top_pct.values,
    "enrichment": enrichment.values
})

out.to_csv(OUTCSV, index=False)
print(out)

print("\nTotal radicals in full dataset:", len(motif_df))
print("Radicals found in RL top-20:", motif_df['is_top20'].sum())

import os
import pandas as pd

BASE = "/content/drive/MyDrive/RL_radical_dft/RL_radical_new_dataset"
RESULT_DIR = os.path.join(BASE, "Results")

TOP20_FILE = os.path.join(RESULT_DIR, "top20_radicals_merged_unique.csv")
MOTIF_FILE = os.path.join(BASE, "dataset/Radical_Name_List-2.xlsx")

# Load files
motif_df = pd.read_excel(MOTIF_FILE)
top20_df = pd.read_csv(TOP20_FILE)

# Clean names
motif_df["Radical name"] = motif_df["Radical name"].astype(str).str.strip()
top20_df["Radical name"] = top20_df["Radical name"].astype(str).str.strip()

# Keep only Top-20 radicals with their classes
top20_with_classes = motif_df.loc[
    motif_df["Radical name"].isin(top20_df["Radical name"]),
    ["Radical name", "Classification"]
].reset_index(drop=True)

print(top20_with_classes)

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
import textwrap
import seaborn as sns

# ==============================
# PATHS
# ==============================
BASE = "/content/drive/MyDrive/RL_radical_dft/RL_radical_new_dataset"
RESULT_DIR = os.path.join(BASE, "Results")
PLOTS_DIR = os.path.join(BASE, "plots")
ENRICH_FILE = os.path.join(RESULT_DIR, "motif_enrichment_full_vs_top20.csv")

os.makedirs(PLOTS_DIR, exist_ok=True)

# ==============================
# LOAD DATA
# ==============================
df = pd.read_csv(ENRICH_FILE)

# Top 5 enriched motifs
df_top5 = df.sort_values("enrichment", ascending=False).head(5)

motifs_raw = df_top5["motif_class"].astype(str)
full_pct = df_top5["pct_full"] * 100
top20_pct = df_top5["pct_top20"] * 100
enrichment = df_top5["enrichment"]

# Wrap motif labels for better readability
motifs = [textwrap.fill(label, width=12) for label in motifs_raw]

# ==============================
# COLORS (PUBLICATION-QUALITY)
# ==============================
palette = sns.color_palette("pastel", len(motifs))
full_color = "#c7c7c7"  # soft gray for full dataset

# ==============================
# UNIFIED 2-PANEL FIGURE
# ==============================
fig, axes = plt.subplots(1, 2, figsize=(17, 7), dpi=600)
plt.subplots_adjust(wspace=0.35)

# ---------- PANEL 1: DISTRIBUTION (FULL vs TOP-20) ----------
x = np.arange(len(motifs))
width = 0.35

axes[0].bar(
    x - width/2,
    full_pct,
    width,
    label="Total Dataset",
    color=full_color,
    edgecolor="black"
)
axes[0].bar(
    x + width/2,
    top20_pct,
    width,
    label="RL Top-20",
    color=palette,
    edgecolor="black"
)

axes[0].set_ylabel("Percentage (%)", fontsize=14)
axes[0].set_xlabel("Motif Class", fontsize=14)
axes[0].set_title("A. Distribution of Motifs in Total Dataset", fontsize=16)
axes[0].set_xticks(x)
axes[0].set_xticklabels(motifs, fontsize=12)
axes[0].grid(axis="y", linestyle="--", alpha=0.5)
axes[0].legend(fontsize=12)

# ---------- PANEL 2: ENRICHMENT (FOLD-CHANGE) ----------
axes[1].bar(
    np.arange(len(motifs)),
    enrichment,
    color=palette,
    edgecolor="black"
)

axes[1].set_ylabel("Fold Enrichment", fontsize=14)
axes[1].set_xlabel("Motif Class", fontsize=14)
axes[1].set_title("B. Enrichment of Motifs in RL Top-20", fontsize=16)
axes[1].set_xticks(np.arange(len(motifs)))
axes[1].set_xticklabels(motifs, fontsize=12)
axes[1].grid(axis="y", linestyle="--", alpha=0.5)

# ---------- MAIN FIGURE TITLE ----------
fig.suptitle(
    "Comparison of Structural Motif Enrichment Analysis of RL-Selected Radicals",
    fontsize=20,
    y=1.02
)

plt.tight_layout()

# ==============================
# SAVE + SHOW
# ==============================
out_path = os.path.join(PLOTS_DIR, "Figure_motif_enrichment_top5.png")
fig.savefig(out_path, bbox_inches="tight")
plt.show()

print(f"Saved motif enrichment figure → {out_path}")

import pandas as pd
import os


# PATHS

BASE = "/content/drive/MyDrive/RL_radical_dft/RL_radical_new_dataset"
RESULT_DIR = os.path.join(BASE, "Results")

TOP20_FILE = os.path.join(RESULT_DIR, "top20_radicals_merged_unique.csv")
MOTIF_FILE = os.path.join(BASE, "dataset/Radical_Name_List-2.xlsx")

OUTCSV = os.path.join(RESULT_DIR, "motif_example_radicals_top20.csv")


# LOAD DATA

motif_df = pd.read_excel(MOTIF_FILE)
motif_df["Radical name"] = motif_df["Radical name"].astype(str).str.strip()

top20_df = pd.read_csv(TOP20_FILE)
top20_df["Radical name"] = top20_df["Radical name"].astype(str).str.strip()

# Merge motif labels with RL top-20 data
merged = pd.merge(
    top20_df,
    motif_df,
    on="Radical name",
    how="left"
)

# Identify motif classes present in the top-20
motif_classes = merged["Classification"].unique()


# Extract 2–3 example radicals per motif
example_rows = []

for motif in motif_classes:
    subset = merged[merged["Classification"] == motif]
    examples = subset.head(3)  # take first 3 for each motif
    example_rows.append(examples)

example_df = pd.concat(example_rows, ignore_index=True)

# Save output
example_df.to_csv(OUTCSV, index=False)

print("\n===== Example Radicals per Motif (Top-20) =====\n")
for motif in motif_classes:
    sub = example_df[example_df["Classification"] == motif]
    print(f"Motif Class: {motif}")
    print(sub[["Radical name"]])
    print()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from textwrap import fill

# INPUT FILES

MOTIF_FILE = "/content/drive/MyDrive/RL_radical_dft/RL_radical_new_dataset/dataset/Radical_Name_List-2.xlsx"
TOP20_FILE = "/content/drive/MyDrive/RL_radical_dft/RL_radical_new_dataset/Results/top20_radicals_merged_unique.csv"


# LOAD AND MERGE

motif_df = pd.read_excel(MOTIF_FILE)
motif_df["Radical name"] = motif_df["Radical name"].astype(str).str.strip()

top20_df = pd.read_csv(TOP20_FILE)
top20_df["Radical name"] = top20_df["Radical name"].astype(str).str.strip()

merged = top20_df.merge(motif_df, on="Radical name", how="left")

features = ["ω", "f⁺", "f⁻", "f⁰"]


# NORMALIZE DESCRIPTORS (0–1)

norm = (merged[features] - merged[features].min()) / (merged[features].max() - merged[features].min())
merged[features] = norm


# AVERAGE PER-MOTIF

motif_avg = merged.groupby("Classification")[features].mean().reset_index()

# Keep only motifs actually present in the top-20
motif_avg = motif_avg.sort_values("ω", ascending=False)


# RADAR PLOT SETUP

N = len(features)
angles = np.linspace(0, 2 * np.pi, N, endpoint=False).tolist()
angles += angles[:1]

# Colorblind safe palette
cb_colors = [
    "#0072B2", "#E69F00", "#F0E442", "#009E73", "#CC79A7",
    "#D55E00", "#56B4E9", "#999999", "#332288", "#882255"
]

plt.figure(figsize=(10, 10), dpi=300)
ax = plt.subplot(111, polar=True)


# PLOT EACH MOTIF

for i, (_, row) in enumerate(motif_avg.iterrows()):
    values = row[features].tolist()
    values += values[:1]

    label = fill(row["Classification"], width=18)

    ax.plot(
        angles, values,
        linewidth=2.0,
        linestyle="-",
        color=cb_colors[i % len(cb_colors)],
        label=label
    )
    ax.fill(
        angles, values,
        alpha=0.12,
        color=cb_colors[i % len(cb_colors)]
    )


# AESTHETICS

ax.set_theta_offset(np.pi / 2)
ax.set_theta_direction(-1)

plt.xticks(angles[:-1], features, fontsize=14)
ax.tick_params(axis='y', labelsize=12)
ax.grid(True, linestyle="--", alpha=0.6)

plt.title(
    "Reactivity Fingerprints of RL-Optimized Radicals\n(Combined Radar Plot by Structural Motif)",
    fontsize=16,
    pad=40,
    loc='center'
)

plt.legend(
    bbox_to_anchor=(1.20, 1.05),
    loc="upper left",
    fontsize=11,
    frameon=False
)

plt.tight_layout()
plt.savefig(
    "/content/drive/MyDrive/RL_radical_dft/RL_radical_new_dataset/Results/combined_radar_plot.png",
    dpi=300,
    bbox_inches="tight"
)
plt.show()



# Ablation study on validation dataset
# Produces per-episode totals under ω-only, f⁻-only, f⁺-only, f⁰-only, full reward

import os
import numpy as np
import pandas as pd
import torch
import matplotlib.pyplot as plt

#PATHS
BASE_DIR    = "/content/drive/MyDrive/RL_radical_dft/RL_radical_new_dataset"
VAL_CSV     = os.path.join(BASE_DIR, "dataset", "val_dataset.csv")
RESULTS_DIR = os.path.join(BASE_DIR, "Results")
PLOTS_DIR   = os.path.join(BASE_DIR, "plots")
BEST_ACTOR  = os.path.join(RESULTS_DIR, "best_actor_td3_validated_20000.pth")
os.makedirs(PLOTS_DIR, exist_ok=True)

# STATE DEFINITION
STATE_COLUMNS = [
    'Electronegativity','Hardness','Electrophilicity','q(N)',
    'f-','f+','f0','s-','s+','s0','s+/s-','s-/s+','s(2)'
]
IDX_OMEGA, IDX_FM, IDX_FP, IDX_F0 = 2, 4, 5, 6
OMEGA_COL = 'Electrophilicity'

# PREPROCESSING
def _safe_ratio(num, den, eps=1e-8):
    n = np.asarray(num, dtype=np.float64)
    d = np.asarray(den, dtype=np.float64)
    return n / (np.sign(den) * np.maximum(np.abs(den), eps))

def preprocess_dataframe(df: pd.DataFrame):
    if 's+/s-' not in df.columns:
        df['s+/s-'] = _safe_ratio(df.get('s+', 0.0), df.get('s-', 1.0))
    if 's-/s+' not in df.columns:
        df['s-/s+'] = _safe_ratio(df.get('s-', 0.0), df.get('s+', 1.0))
    df[STATE_COLUMNS] = df[STATE_COLUMNS].ffill().bfill()
    df['f-'] = df['f-'].clip(-1, 1)
    df['f+'] = df['f+'].clip(-1, 1)
    df['f0'] = df['f0'].clip(-1, 1)
    df[OMEGA_COL] = df[OMEGA_COL].clip(0.0, 6.5)

    mu = df.mean(numeric_only=True)
    sd = df.std(numeric_only=True).replace(0.0, 1.0)
    df_scaled = (df[STATE_COLUMNS] - mu) / sd
    df_scaled['_omega_unscaled'] = df[OMEGA_COL].values.astype(np.float32)
    df_scaled['_omega_mu'] = mu[OMEGA_COL]
    df_scaled['_omega_sd'] = sd[OMEGA_COL]
    return df_scaled.reset_index(drop=True)

# TD3 ACTOR
import torch.nn as nn

def mlp(sizes, act_last=None):
    layers = []
    for i in range(len(sizes)-2):
        layers += [nn.Linear(sizes[i], sizes[i+1]), nn.ReLU()]
    layers.append(nn.Linear(sizes[-2], sizes[-1]))
    if act_last == 'tanh':
        layers.append(nn.Tanh())
    return nn.Sequential(*layers)

class Actor(nn.Module):
    def __init__(self, state_dim, hidden):
        super().__init__()
        self.body = mlp([state_dim, hidden, hidden, 1], act_last='tanh')
    def forward(self, s):
        return self.body(s).squeeze(1)

#ENVIRONMENT
class ContinuousRadicalEnv:
    def __init__(self, df_scaled, target_omega=1.0, success_thr=0.02):
        self.df = df_scaled.reset_index(drop=True)
        self.state_columns = STATE_COLUMNS
        self.num_features = len(self.state_columns)
        self.target_omega = target_omega
        self.success_thr = success_thr
        self.omega_clip = (0.0, 6.5)
        self.high_omega_terminate = 5.0
        self.high_omega_penalty = -5.0
        self.state=None
        self.idx=None

    def reset_idx(self, idx):
        self.idx = idx
        self.state = self.df.loc[self.idx, self.state_columns].values.astype(np.float32)
        self.row_cache = self.df.loc[self.idx]
        return self.state.copy()

    def step(self, delta, pos_clip, neg_clip):
        s = self.state
        mu = float(self.row_cache['_omega_mu'])
        sd = float(self.row_cache['_omega_sd'])
        omega_scaled = float(s[IDX_OMEGA])
        prev = sd * omega_scaled + mu
        a = float(np.clip(delta, -neg_clip, +pos_clip))
        new = np.clip(prev + a, *self.omega_clip)

        done, penalty = False, 0.0
        if new >= self.high_omega_terminate:
            done, penalty = True, self.high_omega_penalty
        if abs(new - self.target_omega) <= self.success_thr:
            done = True

        new_scaled = (new - mu) / (sd if sd != 0 else 1.0)
        ns = s.copy()
        ns[IDX_OMEGA] = new_scaled
        self.state = ns
        return ns.copy(), {"omega": new, "delta": a, "penalty": penalty}

# LOAD BEST MODEL
def load_best_model():
    raw_val = pd.read_csv(VAL_CSV)
    val_df = preprocess_dataframe(raw_val)
    env = ContinuousRadicalEnv(val_df, target_omega=1.0, success_thr=0.02)
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    actor = Actor(env.num_features, hidden=128).to(device)
    actor.load_state_dict(torch.load(BEST_ACTOR, map_location=device))
    actor.eval()
    print(f"Loaded validated actor from {BEST_ACTOR}")
    return actor, env, val_df

#  ROLLOUT UNDER ABLATION
@torch.no_grad()
def rollout_ablation(actor, env, init_idx, steps=10, mode="full", pos_clip=0.05, neg_clip=0.05):
    s = env.reset_idx(init_idx)
    device = next(actor.parameters()).device
    total_r = 0.0
    for _ in range(steps):
        st = torch.from_numpy(s).float().unsqueeze(0).to(device)
        raw = actor(st).item()
        a = raw*pos_clip if raw>=0 else raw*neg_clip
        s, info = env.step(a, pos_clip=pos_clip, neg_clip=neg_clip)
        omega = info["omega"]

        # ---- ablation reward definitions ----
        if mode == "omega":
            r = np.exp(-abs(omega - 1.0))   # proximity only
        elif mode == "f-":
            r = float(s[IDX_FM])
        elif mode == "f+":
            r = float(s[IDX_FP])
        elif mode == "f0":
            r = float(s[IDX_F0])
        else:  # full reward (env default approximation)
            r = np.exp(-abs(omega - 1.0)) + (0.2 * -abs(info["delta"])) + info["penalty"]

        total_r += r
        if omega >= env.high_omega_terminate or abs(omega-1.0) <= env.success_thr:
            break
    return total_r

# MAIN ABLATION LOOP
actor, env, val_df = load_best_model()

totals_omega, totals_fm, totals_fp, totals_f0, totals_bonus = [], [], [], [], []
for idx in range(len(val_df)):
    totals_omega.append(rollout_ablation(actor, env, idx, mode="omega"))
    totals_fm.append(rollout_ablation(actor, env, idx, mode="f-"))
    totals_fp.append(rollout_ablation(actor, env, idx, mode="f+"))
    totals_f0.append(rollout_ablation(actor, env, idx, mode="f0"))
    totals_bonus.append(rollout_ablation(actor, env, idx, mode="full"))

totals_omega = np.array(totals_omega)
totals_fm    = np.array(totals_fm)
totals_fp    = np.array(totals_fp)
totals_f0    = np.array(totals_f0)
totals_bonus = np.array(totals_bonus)

# PLOT HISTOGRAMS
plt.rcParams.update({"font.size":12,"axes.linewidth":1.2,
                     "xtick.major.size":4,"ytick.major.size":4})
fig, axes = plt.subplots(2, 3, figsize=(15, 8), dpi=300)
axes = axes.flatten()

hist_data = [
    (totals_omega, "ω Only",      "#66C2A5"), # pastel teal
    (totals_fm,    "f⁻ Only",     "#8DA0CB"), # pastel lavender
    (totals_fp,    "f⁺ Only",     "#FC8D62"), # pastel coral
    (totals_f0,    "f⁰ Only",     "#E78AC3"), # pastel pink-magenta
    (totals_bonus, "Full Reward", "#A6D854")  # pastel green
]

for i, (arr, title, color) in enumerate(hist_data):
    axes[i].hist(arr, bins=30, color=color, edgecolor="black", alpha=0.8)
    axes[i].set_title(title)
    axes[i].set_xlabel("Per-episode total")
    axes[i].set_ylabel("Frequency")
    axes[i].grid(True, linestyle="--", alpha=0.6)

axes[-1].axis("off")

fig.suptitle("Distribution of reward components from ablation analysis on Validation Dataset By RL Model",
             fontsize=16, y=0.98)
plt.tight_layout(rect=[0, 0, 1, 0.95])

ablation_out = os.path.join(PLOTS_DIR, "ablation_histograms_validation.png")
plt.savefig(ablation_out, bbox_inches="tight")
plt.show()
print(f"Ablation histograms saved : {ablation_out}")

#!/usr/bin/env python3
import os
import numpy as np
import pandas as pd
import torch
import torch.nn as nn
import matplotlib.pyplot as plt
import seaborn as sns

BASE_DIR = "/content/drive/MyDrive/RL_radical_dft/RL_radical_new_dataset"
VAL_CSV = os.path.join(BASE_DIR, "dataset", "val_dataset.csv")
RESULTS_DIR = os.path.join(BASE_DIR, "Results")
PLOTS_DIR = os.path.join(BASE_DIR, "plots")
BEST_ACTOR = os.path.join(RESULTS_DIR, "best_actor_td3_validated_5000.pth")
CLASSIFIED_XLSX = os.path.join(BASE_DIR, "dataset", "Radical_Name_List-2.xlsx")
OUTDIR_ANALYSIS = "/content/drive/MyDrive/RL_radical_dft/Analysis_outputs"
os.makedirs(PLOTS_DIR, exist_ok=True)
os.makedirs(OUTDIR_ANALYSIS, exist_ok=True)

STATE_COLUMNS = [
    "Electronegativity","Hardness","Electrophilicity","q(N)",
    "f-","f+","f0","s-","s+","s0","s+/s-","s-/s+","s(2)"
]
IDX_OMEGA, IDX_FM, IDX_FP, IDX_F0 = 2, 4, 5, 6
OMEGA_COL = "Electrophilicity"

def _safe_ratio(n, d, eps=1e-8):
    n = np.asarray(n); d = np.asarray(d)
    return n / (np.sign(d) * np.maximum(np.abs(d), eps))

def preprocess_dataframe(df):
    if "s+/s-" not in df.columns:
        df["s+/s-"] = _safe_ratio(df.get("s+",0), df.get("s-",1))
    if "s-/s+" not in df.columns:
        df["s-/s+"] = _safe_ratio(df.get("s-",0), df.get("s+",1))

    df[STATE_COLUMNS] = df[STATE_COLUMNS].ffill().bfill()
    df["f-"] = df["f-"].clip(-1,1)
    df["f+"] = df["f+"].clip(-1,1)
    df["f0"] = df["f0"].clip(-1,1)
    df[OMEGA_COL] = df[OMEGA_COL].clip(0,6.5)

    mu = df.mean(numeric_only=True)
    sd = df.std(numeric_only=True).replace(0.0,1.0)

    out = (df[STATE_COLUMNS] - mu)/sd
    out["_omega_unscaled"] = df[OMEGA_COL].values
    out["_omega_mu"] = mu[OMEGA_COL]
    out["_omega_sd"] = sd[OMEGA_COL]
    out["_radical_name"] = df["Radical name"].astype(str)
    return out.reset_index(drop=True)

def mlp(sizes, act_last=None):
    layers=[]
    for i in range(len(sizes)-2):
        layers += [nn.Linear(sizes[i],sizes[i+1]), nn.ReLU()]
    layers.append(nn.Linear(sizes[-2], sizes[-1]))
    if act_last=="tanh": layers.append(nn.Tanh())
    return nn.Sequential(*layers)

class Actor(nn.Module):
    def __init__(self, state_dim, hidden):
        super().__init__()
        self.body = mlp([state_dim, hidden, hidden, 1], act_last="tanh")
    def forward(self, s): return self.body(s).squeeze(1)

class ContinuousRadicalEnv:
    def __init__(self, df_scaled, target_omega=1.0, success_thr=0.02):
        self.df = df_scaled
        self.state_columns = STATE_COLUMNS
        self.num_features = len(STATE_COLUMNS)
        self.target_omega = target_omega
        self.success_thr = success_thr
        self.omega_clip = (0,6.5)
        self.high_omega_terminate = 5.0
        self.high_omega_penalty = -5.0

    def reset_idx(self, idx):
        self.idx = idx
        self.state = self.df.loc[idx, self.state_columns].values.astype(np.float32)
        self.row = self.df.loc[idx]
        return self.state.copy()

    def step(self, delta, pos_clip, neg_clip):
        s = self.state
        mu = self.row["_omega_mu"]
        sd = self.row["_omega_sd"]
        prev = sd*s[IDX_OMEGA] + mu

        a = np.clip(delta, -neg_clip, pos_clip)
        new = np.clip(prev + a, *self.omega_clip)

        done=False; success=False; penalty=0
        if new >= self.high_omega_terminate:
            done=True; penalty=self.high_omega_penalty
        if abs(new - self.target_omega) <= self.success_thr:
            success=True; done=True

        new_scaled = (new - mu) / (sd if sd!=0 else 1)
        ns = s.copy(); ns[IDX_OMEGA] = new_scaled
        self.state = ns
        return ns.copy(), {"omega":new,"delta":a,"success":success,"done":done,"penalty":penalty}

def load_best_model():
    df_raw = pd.read_csv(VAL_CSV)
    df_scaled = preprocess_dataframe(df_raw)
    env = ContinuousRadicalEnv(df_scaled)
    device=torch.device("cuda" if torch.cuda.is_available() else "cpu")
    actor=Actor(env.num_features,128).to(device)
    actor.load_state_dict(torch.load(BEST_ACTOR, map_location=device))
    actor.eval()
    return actor, env, df_scaled, df_raw

@torch.no_grad()
def rollout_ablation(actor, env, idx, mode="full", steps=10, pos_clip=0.05, neg_clip=0.05, return_success=False):
    s = env.reset_idx(idx)
    device = next(actor.parameters()).device
    total_r=0; final_omega=None; success=False

    for _ in range(steps):
        st = torch.from_numpy(s).float().unsqueeze(0).to(device)
        raw = actor(st).item()
        a = raw*pos_clip if raw>=0 else raw*neg_clip
        s,info = env.step(a, pos_clip, neg_clip)
        final_omega = info["omega"]

        if mode=="omega": r = np.exp(-abs(final_omega-1))
        elif mode=="f-": r = s[IDX_FM]
        elif mode=="f+": r = s[IDX_FP]
        elif mode=="f0": r = s[IDX_F0]
        else: r = np.exp(-abs(final_omega-1)) + (0.2 * -abs(info["delta"])) + info["penalty"]

        total_r += r
        if info["success"]: success=True
        if info["done"]: break

    if return_success: return total_r, success, final_omega
    return total_r

actor, env, df_scaled, df_raw = load_best_model()
n = len(df_scaled)

totals_omega=np.zeros(n)
totals_fm=np.zeros(n)
totals_fp=np.zeros(n)
totals_f0=np.zeros(n)
totals_full=np.zeros(n)
succ_full=np.zeros(n)
omega_final=np.zeros(n)

for i in range(n):
    totals_omega[i] = rollout_ablation(actor,env,i,mode="omega")
    totals_fm[i] = rollout_ablation(actor,env,i,mode="f-")
    totals_fp[i] = rollout_ablation(actor,env,i,mode="f+")
    totals_f0[i] = rollout_ablation(actor,env,i,mode="f0")
    tfull, succ, ofin = rollout_ablation(actor,env,i,mode="full",return_success=True)
    totals_full[i]=tfull; succ_full[i]=1 if succ else 0; omega_final[i]=ofin

df_row = pd.DataFrame({
    "Radical name": df_raw["Radical name"],
    "Atom": df_raw["Atom"],
    "total_omega": totals_omega,
    "total_fm": totals_fm,
    "total_fp": totals_fp,
    "total_f0": totals_f0,
    "total_full": totals_full,
    "success_full": succ_full,
    "omega_initial": df_scaled["_omega_unscaled"],
    "omega_final": omega_final
})

path_row = os.path.join(OUTDIR_ANALYSIS,"ablation_per_row_with_omega.csv")
df_row.to_csv(path_row,index=False)

def normalize_name(x):
    return str(x).lower().replace(" ","").replace("-","").replace(".","")

full = pd.read_excel(CLASSIFIED_XLSX)
rad_col = [c for c in full.columns if "radical" in c.lower()][0]
class_col= [c for c in full.columns if "class" in c.lower()][0]

df_rad = (
    df_row.groupby("Radical name",as_index=False)
    .agg({
        "total_full":"mean",
        "success_full":"mean",
        "omega_initial":"mean",
        "omega_final":"mean"
    })
    .rename(columns={
        "total_full":"mean_total_full",
        "success_full":"mean_success_full",
        "omega_initial":"mean_omega_initial",
        "omega_final":"mean_omega_final"
    })
)

df_rad["radical_norm"] = df_rad["Radical name"].apply(normalize_name)
full["radical_norm"] = full[rad_col].apply(normalize_name)

df_merged = df_rad.merge(
    full[["radical_norm",class_col]].rename(columns={class_col:"structural_class"}),
    on="radical_norm", how="left"
)

def classify_motif(name: str) -> str:
    s = str(name).lower()
    if any(k in s for k in ["naphth","anthrac","indol","quinol"]): return "Extended aromatic"
    if any(k in s for k in ["benzyl","benzylic","phenyl","phenoxy","tolyl"]): return "Benzylic"
    if any(k in s for k in ["allyl","propenyl","propen-","-en-1-yl","-en-2-yl","-en-3-yl"]): return "Allylic / conjugated"
    if any(k in s for k in ["acyl","formyl","acetyl","benzoyl","propionyl","butanoyl"]): return "Acyl / carbonyl"
    if any(k in s for k in ["amino","nitro","azo","diazo","pyridyl","anilid","imino"]): return "Nitrogen-centered"
    if any(k in s for k in ["oxy","peroxy","hydroperoxy","oxyl"]): return "Oxygen-centered"
    if "cyclo" in s: return "Cyclic (non-aromatic)"
    if any(k in s for k in ["methyl","ethyl","propyl","butyl","pentyl","hexyl"]): return "Saturated alkyl"
    if any(k in s for k in ["sulfon","sulf","thio","phosph","phosphon","boron","sil"]): return "S/P/B/Si-substituted"
    return "Other"

df_merged["structural_motif"] = df_merged["Radical name"].apply(classify_motif)

motif_stats = (
    df_merged.groupby("structural_motif")
    .agg({"mean_success_full":"mean"})
    .sort_values("mean_success_full", ascending=False)
)

sns.set_theme(context="paper", style="ticks")
plt.rcParams["figure.dpi"] = 600
plt.rcParams["savefig.dpi"] = 600
plt.rcParams["font.family"] = "DejaVu Serif"
plt.rcParams["axes.linewidth"] = 1.3
plt.rcParams["axes.labelsize"] = 15
plt.rcParams["xtick.labelsize"] = 13
plt.rcParams["ytick.labelsize"] = 13

valid = df_merged.dropna(subset=["structural_class"])

df_cls = valid.groupby("structural_class")["mean_success_full"].mean().reset_index().sort_values("mean_success_full", ascending=False)
df_w = valid.groupby("structural_class")["mean_omega_final"].mean().reset_index().sort_values("mean_omega_final", ascending=False)
df_r = valid.groupby("structural_class")["mean_total_full"].mean().reset_index().sort_values("mean_total_full", ascending=False)

col_success_cls = sns.color_palette("pastel")[0]
col_omega_cls   = sns.color_palette("pastel")[1]
col_reward_cls  = sns.color_palette("pastel")[2]
col_success_mot = sns.color_palette("pastel")[3]

fig, axes = plt.subplots(2, 2, figsize=(18, 12), dpi=600)

# ✅ SPACING FIX ONLY
plt.subplots_adjust(
    hspace=0.40,
    wspace=0.80,   # more space between columns
    left=0.30,     # more room for left labels
    right=0.98
)

axes = axes.flatten()

axes[0].barh(df_cls["structural_class"], df_cls["mean_success_full"],
             color=col_success_cls, edgecolor="black")
axes[0].invert_yaxis()
axes[0].grid(alpha=0.3)
axes[0].set_title("A. RL Success Probability Across Radical Classes", pad=14)
axes[0].set_xlabel("Mean Success Probability")

axes[1].barh(df_w["structural_class"], df_w["mean_omega_final"],
             color=col_omega_cls, edgecolor="black")
axes[1].invert_yaxis()
axes[1].grid(alpha=0.3)
axes[1].set_title("B. Electrophilicity After RL Optimization", pad=14)
axes[1].set_xlabel("Mean ω After Optimization (eV)")

axes[2].barh(df_r["structural_class"], df_r["mean_total_full"],
             color=col_reward_cls, edgecolor="black")
axes[2].invert_yaxis()
axes[2].grid(alpha=0.3)
axes[2].set_title("C. Average RL Reward Across Radical Classes", pad=14)
axes[2].set_xlabel("Mean RL Reward")

axes[3].barh(motif_stats.index, motif_stats["mean_success_full"],
             color=col_success_mot, edgecolor="black")
axes[3].invert_yaxis()
axes[3].grid(alpha=0.3)
axes[3].set_title("D. RL Success Probability Across Structural Motifs", pad=14)
axes[3].set_xlabel("Mean Success Probability")

fig.suptitle(
    "Ablation Study of Radical Reactivity Across Structural Classes and Motifs on Test Dataset",
    fontsize=18,
    y=0.995
)

fig_path = os.path.join(PLOTS_DIR, "Unified_4Panel_Results.png")
fig.savefig(fig_path, bbox_inches="tight")
plt.show()

print(f"Saved unified figure : {fig_path}")

